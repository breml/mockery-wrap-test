// Code generated by mockery. DO NOT EDIT.
// template: wrappers/fmt_print.gotmpl

package {{ .PkgName }}

import (
{{ range .Imports -}}
	{{ .Alias }} "{{ .Path }}"
{{ end -}}
)


{{ range $i, $mock := .Mocks }}

	{{ $decorator := (or .TemplateData.DecoratorName (printf "%sWithFmtPrint" $mock.InterfaceName)) }}

	// {{$decorator}} implements {{ $.SrcPkgQualifier }}{{ $mock.InterfaceName }} that is instrumented with fmt.Print on entry and exit.
	type {{$decorator}} struct {
		_base {{ $.SrcPkgQualifier }}{{ $mock.InterfaceName }}
	}

	// New{{$decorator}} instruments an implementation of the {{ $.SrcPkgQualifier }}{{ $mock.InterfaceName }} with fmt.Print on entry and exit.
	func New{{$decorator}}(base {{ $.SrcPkgQualifier }}{{ $mock.InterfaceName }}) {{$decorator}} {
		return {{$decorator}}{
			_base: base,
		}
	}

	{{ range $method := $mock.Methods }}

		// {{$method.Name}} implements {{ $.SrcPkgQualifier }}{{ $mock.InterfaceName }}.
		func (_d {{$decorator}}) {{ $method.Declaration }} {
			fmt.Print("=> calling {{$method.Name}}")
			{{- if $method.HasParams }}
				fmt.Printf(" with args: " + strings.Repeat("%#v, ", {{ len $method.Params }}), {{ $method.ArgCallListNoEllipsis }})
			{{- end }}
			fmt.Println()

			defer func() {
				fmt.Print("<= method {{$method.Name}} returned")
				{{- if $method.HasReturns }}
					{{- if $method.ReturnsError }}
						if err != nil {
							fmt.Print(" with error")
						}
					{{- end }}
					fmt.Printf(" with returns: " + strings.Repeat("%#v, ", {{ len $method.Returns }}), {{ $method.ReturnArgNameList }})
				{{ end }}
				fmt.Println()
			}()

			{{ if gt ($method.Returns | len) 0 -}}
			return
			{{- end }} _d._base.{{ $method.Call }}
		}

	{{ end }}

{{ end }}
